#!/usr/bin/env python3
# -*- coding: utf-8 -*- 

import os 
import tornado.httpserver
import tornado.ioloop
import tornado.web
import tornado.websocket
import tornado.concurrent
import concurrent.futures
import configparser
import time
import sys
import alsaaudio
import threading
import gc
import datetime
from sa818 import *
from collections import namedtuple

############ Global variables ##################################
CTRX=None	
config = configparser.ConfigParser()
config.read('UHRRM.conf')
e="No"
PTTgpio=str(config['OrangePI']['PTTGPIO'])
RXgpio=str(config['OrangePI']['RXGPIO'])

radio_opts_struct = namedtuple("radio_opts_struct","bw frequency offset squelch ctcss dcs level emphasis highpass lowpass close_tail")	
radio_opts = radio_opts_struct(
bw=None,
frequency=None,
offset=None,
squelch=None,
ctcss=None,
dcs=None,
level=None,
emphasis=None,
highpass=None,
lowpass=None,
close_tail=None
)
############ SA818 ##################################
def SA818init():
	global radio, radio_opts, config
	
	radio = SA818(config['SA818']['serial'], config['SA818']['rate'])
	radio.version()
	
	SA818OptioizeConf()
	
	print("\n\
	bw="+str(radio_opts.bw)+" 0=NARROW (12.5KHz), 1=WIDE (25KHx)\n\
	frequency="+str(radio_opts.frequency)+"\n\
	offset="+str(radio_opts.offset)+"\n\
	squelch="+str(radio_opts.squelch)+"\n\
	ctcss="+str(radio_opts.ctcss)+"\n\
	dcs="+str(radio_opts.dcs)+"\n\
	level="+str(radio_opts.level)+"\n\
	emphasis="+str(radio_opts.emphasis)+"\n\
	highpass="+str(radio_opts.highpass)+"\n\
	lowpass="+str(radio_opts.lowpass)+"\n\
	\n\ ")

	
	radio.set_radio(radio_opts)
	radio.set_filter(radio_opts)
	radio.set_volume(radio_opts)

def SA818OptioizeConf():
	global radio_opts, config
	
	Rctcss = None if config['SA818']['ctcss'] in ["0", "None"] else type_ctcss(str(config['SA818']['ctcss']))
	Rdcs = None if config['SA818']['dcs'] in ["0", "None"] else type_dcs(str(config['SA818']['dcs']))
	
	radio_opts = radio_opts_struct(
	bw=int(config['SA818']['bw']),
	frequency=type_frequency(config['SA818']['frequency']),
	offset=float(config['SA818']['offset']),
	squelch=type_squelch(config['SA818']['squelch']),
	ctcss=Rctcss,
	dcs=Rdcs,
	level=type_level(config['SA818']['level']),
	emphasis=yesno(config['SA818']['emphasis']),
	highpass=yesno(config['SA818']['highpass']),
	lowpass=yesno(config['SA818']['lowpass']),
	close_tail=None
	)

def SA818Conf(field, setting):
	global radio, radio_opts
	
	if field in radio_opts._fields:
		config['SA818'][field]=setting
		SA818OptioizeConf()
		if field in ['bw', 'frequency', 'offset', 'squelch', 'ctcss', 'dcs']:
			radio.set_radio(radio_opts)
		elif field in ['emphasis', 'highpass', 'lowpass']:
			radio.set_filter(radio_opts)
	with open('UHRRM.conf', 'w') as configfile:
		config.write(configfile)
		
def SA818savescanFreqs(freqs):
	config['SA818']['scan_frequencies']=""
	for freq in freqs.split(','):
		freq = freq.strip()
		if freq:
			config['SA818']['scan_frequencies'] += "{:.4f}".format(type_frequency(freq))+","
	config['SA818']['scan_frequencies'] = config['SA818']['scan_frequencies'][:-1]
	with open('UHRRM.conf', 'w') as configfile:
		config.write(configfile)
		

############ GPIO ##################################
def PTTinit():
	global PTTgpio
	os.system("echo "+PTTgpio+" > /sys/class/gpio/export > /dev/null 2>&1")
	os.system("echo out > /sys/class/gpio/gpio"+PTTgpio+"/direction > /dev/null 2>&1")
	os.system("echo "+RXgpio+" > /sys/class/gpio/export > /dev/null 2>&1")
	os.system("echo in > /sys/class/gpio/gpio"+RXgpio+"/direction > /dev/null 2>&1")
	
def PTTset(state):
	global PTTgpio
	print("PTT:"+state)
	if(state == "true"):
		state = "1"
	else:
		state = "0"
	os.system("echo "+state+" > /sys/class/gpio/gpio"+PTTgpio+"/value")
	return os.popen("cat /sys/class/gpio/gpio"+PTTgpio+"/value").read()

############ BaseHandler tornado ##############
class BaseHandler(tornado.web.RequestHandler):
	def get_current_user(self):
		return self.get_secure_cookie("user")

############ websocket for control TRX ##############
ControlTRXHandlerClients = []
LastPing = time.time()

class WS_ControlTRX(tornado.websocket.WebSocketHandler):
	executor = concurrent.futures.ThreadPoolExecutor(max_workers=4)

	@tornado.concurrent.run_on_executor
	def SA818Conf_setup(self, field, setting):
		SA818Conf(field, setting)
		pass
	
	def SA818SF(self, freq):
		print("freq:"+freq)
		radio.scan_freq(float(freq))
		status = int(os.popen("cat /sys/class/gpio/gpio"+RXgpio+"/value").read())
		print(status)
		if status:
			return freq
		else:
			return 0
		pass

	def open(self):
		global ws_control_trx_instance
		ws_control_trx_instance = self
		print('new connection on ControlTRX socket.')
		if(config['SERVER']['yournameserver']!=""):
			self.write_message("ENT: "+config['SERVER']['yournameserver']);
		self.set_nodelay(True)
		
	@tornado.gen.coroutine
	def on_message(self, data) :
		global LastPing, radio_opts, scanFlag
		print(data)
		
		try:
			(action, datato) = data.split(':')
		except ValueError:
			action = data
			pass
			
		if(action == "PING"):
			yield self.write_message("PONG")
		elif(action == "setPTT"):
			yield self.write_message("getPTT:"+str(PTTset(datato)))
		elif(action == "scanFREQ"):
			try:
				rep = self.SA818SF("{:.4f}".format(type_frequency(datato)))
				yield self.write_message("scanFREQ:"+str(rep)) 
			except:
				pass
		elif(action == "getCONFIG"):
			result_string = ",".join([f"{field}={value}" for field, value in radio_opts._asdict().items()])
			yield self.write_message("getCONFIG:"+str(result_string)) 
			yield print("getCONFIG:"+str(result_string))
			yield self.write_message("getscanFREQS:"+str(config['SA818']['scan_frequencies'])) 
		elif(action == "setCONFIG"):
			(field, setting) = datato.split('=')
			yield self.SA818Conf_setup(field, setting)
			yield self.write_message("setCONFIG:OK")
		elif(action == "setscanFREQS"):
			yield SA818savescanFreqs(datato)
			yield self.write_message("setscanFREQS:OK")
			
			
		LastPing = time.time();
			
	def on_close(self):
		global ws_control_trx_instance
		ws_control_trx_instance = None
		gc.collect()
		
############ websocket for send RX audio from TRX ##############
flagWavstart = False

class loadWavdata(threading.Thread):

	def __init__(self):
		global flagWavstart
		threading.Thread.__init__(self)
		self.inp = alsaaudio.PCM(alsaaudio.PCM_CAPTURE, alsaaudio.PCM_NORMAL, channels=1, rate=8000, format=alsaaudio.PCM_FORMAT_FLOAT_LE, periodsize=256, device=config['AUDIO']['inputdevice'])
		print('recording...')

	def run(self):
		global Wavframes, flagWavstart, AudioRXHandlerClients 
		ret=b''
		while True:
			while not flagWavstart:
				time.sleep(0.5)
			l, ret = self.inp.read()
			if l > 0:
				AudioRXHandlerClients.Wavframes.append(ret)
			else:
				print("overrun")
				time.sleep(0.01)
				

class WS_AudioRXHandler(tornado.websocket.WebSocketHandler):

	def open(self):
		self.set_nodelay(True)
		global flagWavstart, AudioRXHandlerClients
		AudioRXHandlerClients = self
		self.Wavframes = []
		print('new connection on AudioRXHandler socket.')
		flagWavstart = True
		self.tailstream()
		
	@tornado.gen.coroutine
	def tailstream(self):
		while flagWavstart:
			while len(self.Wavframes)==0:
				yield tornado.gen.sleep(0.1)
			try:
				yield self.write_message(self.Wavframes[0],binary=True)
				del self.Wavframes[0]
			except tornado.websocket.WebSocketClosedError:
				print("WebSocket closed. Stopping tailstream.")
				break
			
	def on_close(self):
		global flagWavstart
		print('connection closed for audioRX')
		flagWavstart = False
		self.Wavframes = []
		gc.collect()

############ websocket for control TX ##############
last_AudioTXHandler_msg_time=0
AudioTXHandlerClients = []

class WS_AudioTXHandler(tornado.websocket.WebSocketHandler):

	def stoppttontimeout(self):
		global last_AudioTXHandler_msg_time
		try:
			if time.time() > last_AudioTXHandler_msg_time + 10:
				if self.ws_connection and CTRX.infos["PTT"]==True:
					PTTset("false")
					print("stop ptt on timeout")
		except:
			return None
		tornado.ioloop.IOLoop.instance().add_timeout(datetime.timedelta(seconds=1), self.stoppttontimeout)


	def TX_init(self, msg) :
		try:
			itrate, is_encoded, op_rate, op_frm_dur = [int(i) for i in msg.split(',')]
			self.is_encoded = is_encoded
			self.frame_size = op_frm_dur * op_rate
			device = config['AUDIO']['outputdevice']
			self.inp = alsaaudio.PCM(alsaaudio.PCM_PLAYBACK, alsaaudio.PCM_NONBLOCK, channels=1, rate=itrate, format=alsaaudio.PCM_FORMAT_S16_LE, periodsize=2048, device=device)		
		except:
			print("TX pcm device busy")
	
	def open(self):
		global last_AudioTXHandler_msg_time, AudioTXHandlerClients
		AudioTXHandlerClients = self
		print('new connection on AudioTXHandler socket.')
		last_AudioTXHandler_msg_time=time.time()
		self.stoppttontimeout()
		self.set_nodelay(True)

	def on_message(self, data) :
		global last_AudioTXHandler_msg_time
		last_AudioTXHandler_msg_time=time.time()
		
		if str(data).startswith('m:') :
			self.TX_init(str(data[2:]))
		elif str(data).startswith('s:') :
			self.inp.close()
		else :
			self.inp.write(data)
			gc.collect()

	def on_close(self):
		if(hasattr(self,"inp")):
			self.inp.close()
		PTTset("false")
		print('connection closed for TX socket')	

############ Main ##############
class MainHandler(BaseHandler):

	def get(self):
		self.application.settings.get("compiled_template_cache", False)
		self.set_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')
		self.render("www/index.html")

if __name__ == "__main__":

	try:
		SA818init()
	except (IOError, SystemError) as err:
		print(err)

	try:
		
		PTTinit()
		
		threadloadWavdata = loadWavdata()
		threadloadWavdata.start()
		
		app = tornado.web.Application([
		(r'/WSaudioRX', WS_AudioRXHandler),
		(r'/WSaudioTX', WS_AudioTXHandler),
		(r'/WSCTRX', WS_ControlTRX),
		(r'/', MainHandler),
		(r'/(.*)', tornado.web.StaticFileHandler, { 'path' : './www' })
		],debug=bool(config['SERVER']['debug']), websocket_ping_interval=10, cookie_secret=config['SERVER']['cookie_secret'])
	except:
		e = str(sys.exc_info())
		print(e)
		
	http_server = tornado.httpserver.HTTPServer(app, ssl_options={
	"certfile": os.path.join(config['SERVER']['certfile']),
	"keyfile": os.path.join(config['SERVER']['keyfile']),
	})
	http_server.listen(int(config['SERVER']['port']))
	print('HTTP server started.')
	tornado.ioloop.IOLoop.instance().start()
